metadata {
	// v0.3
    definition (name: "MQTT Client", namespace: "ukusa", author: "Kevin Hawkins",importUrl: "https://raw.githubusercontent.com/xAPPO/MQTT/development/MQTT%20Client%20driver") {
        capability "Initialize"
		//capability "Telnet"  // temporary kludge

        command "publishMsg", ["String","String"]
		command "subscribeTopic",["String"]
		
		//command "createChild", ["String"]  // not using device children currently
		//command "deleteChild", ["String"]
		//command "setStateTopic", ["String","String"]
		//command "setCommandTopic", ["String","String"]
		
		command "reset"
		command "setStateVar"; ["String","String"]
		attribute "RXTopic", "string"
		attribute "OnOffDev", "string"
		attribute "DimDev", "string"
		//attribute "OnOff", "string"
    }
    preferences {
		input name: "MQTTBroker", type: "text", title: "MQTT Broker Address", description: "e.g. tcp://192.168.1.17:1883", required: true, displayDuringSetup: true
		input name: "username", type: "text", title: "MQTT Username", description: "(blank if none)", required: false, displayDuringSetup: true
		input name: "password", type: "password", title: "MQTT Password", description: "(blank if none)", required: false, displayDuringSetup: true
		//input name: "clientID", type: "text", title: "MQTT Client ID", description: "(blank for auto)",defaultValue: "Hubitat Elevation", required: false, displayDuringSetup: true
		//input name: "spare", type: "text", title: "MQTT user", description: "User (blank if none)", required: false, displayDuringSetup: true
		//input name: "Retain", type: "bool", title: "Retain published states", required: true, defaultValue: false
    }

}

import groovy.transform.Field  // TODO needed ?

import static hubitat.helper.InterfaceUtils.alphaV1mqttConnect
import static hubitat.helper.InterfaceUtils.alphaV1mqttDisconnect
import static hubitat.helper.InterfaceUtils.alphaV1mqttSubscribe
import static hubitat.helper.InterfaceUtils.alphaV1mqttUnsubscribe
import static hubitat.helper.InterfaceUtils.alphaV1parseMqttMessage
import static hubitat.helper.InterfaceUtils.alphaV1mqttPublish



def installed() {
    log ("installed...", "WARN")
}

def initialize() {
	//def hub = location.hubs[0]
	if (state.normHubName==null) state.normHubName = "temporary"
    try {
		alphaV1mqttConnect(device, settings?.MQTTBroker, "Hubitat_${state.normHubName}", settings?.username,settings?.password)
        //give it a chance to start
        pauseExecution(1000)
    } catch(e) {
        log ("initialize error: ${e.message}", "ERROR")
		//TODO retries
    }
	log.info "MQTT client pre4 alpha3 initialised"
	log ("Connected as Hubitat_${state.normHubName} to MQTT broker ${settings?.MQTTBroker}", "INFO")
	state.connectionAttempts = 0
	state.delay=100  //delay between events - increase if you have a lot of discovered MQTT devices > 100
    state.device=""
	
	//state.numDimDevices=0  // not using local devices
	//state.DimDevices=[]
	//state.numOnOffDevices=0
    //state.OnOffDevices=[]
}

//TODO Improve error handling

def mqttClientStatus(String status){
    log ("mqttStatus- error: ${status}", "ERROR")
}



def publishMsg(String topic, String payload,int qos = 1, boolean retained = false ) {
	if (payload==null) log("Publish payload is null for topic ${topic}","ERROR")
	if (topic==null) log("Publish topic is null for payload ${payload}","ERROR")
    alphaV1mqttPublish(device, topic, payload, qos, retained)
}

def subscribeTopic (String s) {
	log ("MQTT subscribing to: " + s, "INFO")
	alphaV1mqttSubscribe(device, s)
}

def updated() {
    log ("MQTT client updated...", "INFO")
    initialize()
}

def uninstalled() {
    log ("disconnecting from mqtt", "INFO")
    alphaV1mqttDisconnect(device)
}

// Key method Handles all the data back from MQTT subscriptions
def parse(String description) {
	def topic=alphaV1parseMqttMessage(description).topic.split('/')
	def topicCount=topic.size()
	def payload=alphaV1parseMqttMessage(description).payload.split(',')
	
	// TODO make more use of topicCount for topic validation - some topics that currently match have further subTopics
	
	if (topic[0]==state.HAStatestreamTopic)
		{
			if (topic[1]=='status') {  // HA LWT
				if (payload[0]=="online") {
					log ("Home Assistant [${state.HAStatestreamTopic}] is ONLINE","INFO")
					def evt23 = createEvent(name: "HASynch", value: state.HAStatestreamTopic, isStateChange: true)
					return evt23
				}
				else if (payload[0]=="offline") {
					log ("Home Assistant [${state.HAStatestreamTopic}] is OFFLINE","INFO")
				}
				return
			}
			if (topic[1]=='sensor') {

				if (topic[3]=='state'){
				//log ("RX::Sensor state::  " + topic[2] + " is " + payload[0], "TRACE")
				def evt10 = createEvent(name: "Sensor", value: topic[2], data: [status: payload[0]], isStateChange: true)  //, key2: payload])
				pause (state.delay) // pace
				return evt10
				}
				else if (topic[3]=='friendly_name'){ 
				log ("Device ${topic[2]} is a HA sensor and is called " +payload[0], "TRACE")
				def evt11= createEvent(name: "HASensorDev", value: topic[2], data: [label: deQuote(payload[0])], isStateChange: true)
				pause (state.delay) // pace
				return evt11
				}
				else if (topic[3]=='unit_of_measurement'){ 
				def evt11= createEvent(name: "SensorUnit", value: topic[2], data: [payload: payload[0]], isStateChange: true)
				pause (state.delay) // pace
				return evt11
				}
			}
			
			if (topic[1]=='binary_sensor') {

				if (topic[3]=='state'){
				//log ("RX::Binary Sensor state::  " + topic[2] + " is " + payload[0], "DEBUG")
				def evt10 = createEvent(name: "BinarySensor", value: topic[2], data: [status: payload[0]], isStateChange: true)  //, key2: payload])
				pause (state.delay) // pace
				return evt10
				}
				else if (topic[3]=='friendly_name'){ 
				log ("Device ${topic[2]} is a HA binary sensor and is called " +payload[0], "TRACE")
				def evt19 = createEvent(name: "LabelDevice", value: "MQTT:HA_"+topic[2], data: [label: deQuote(payload[0])], isStateChange: true)
				 //return evt19
				// just renames the device as creation now from 'device_class  // need to ensure device_class arrives first so driver is correct when created
				//def evt19= createEvent([name: "HABinarySensorDev", value: topic[2], data: [label: payload[0]]])
				pause (state.delay) // pace  // maybe extend this if needed to ensure above
				return evt19
				}
				else if (topic[3]=='device_class'){ 
				//log ("Device ${topic[2]} is a HA binary sensor and is of type " +payload[0], "TRACE")
				// create device from here as need device_class to select driver
				def evt18= createEvent(name: "HABinarySensorDev", value: topic[2], data: [type: deQuote(payload[0])], isStateChange: true)  // TODO handle in app
				pause (state.delay) // pace
				return evt18
				}
			}

		else if (topic[1]=='switch') {
			if (topic[3]=='friendly_name') {
				log ("Device ${topic[2]} is a HA switch and is called " +payload[0], "TRACE")
				def evt3= createEvent(name: "HASwitchDev", value: topic[2], data: [label: deQuote(payload[0])], isStateChange: true)
				pause (state.delay) // pace
				return evt3
			}
			if (topic[3]=='state'){
				def evt4 = createEvent(name: "OnOff", value: topic[2], data: [status: payload[0]], isStateChange: true)  //, key2: payload])
				pause (state.delay) // pace
				return evt4
			}
			log ("Unhandled HA (a) MQTT parse  ${topic[0]}  ${topic[1]}  ${topic[2]}  ${topic[3]} - ${payload[0]}", "WARN")
			return
		}
			
		else if (topic[1]=='group') {  
			if (topic[3]=='friendly_name') {
				log ("Device ${topic[2]} is a HA group and is called " +payload[0], "TRACE")
				def evt3= createEvent(name: "HAGroupDev", value: topic[2], data: [label: deQuote(payload[0])], isStateChange: true)
				pause (state.delay) // pace
				return evt3
			}
			if (topic[3]=='state'){
				def evt4 = createEvent(name: "Group", value: topic[2], data: [status: payload[0]], isStateChange: true)  //, key2: payload])
				pause (state.delay) // pace
				//log ("Device ${topic[2]} is a HA group and is turned " +payload[0], "TRACE")
				return evt4
			}
			log ("Unhandled HA (b) MQTT parse  ${topic[0]}  ${topic[1]}  ${topic[2]}  ${topic[3]} - ${payload[0]}", "WARN")
			return
		}
			
		else if (topic[1]=='input_boolean') { 
			if (topic[3]=='friendly_name') {
				log ("Device ${topic[2]} is a HA input boolean and is called " +payload[0], "TRACE")
				def evt3= createEvent(name: "HAInputBooleanDev", value: topic[2], data: [label: deQuote(payload[0])], isStateChange: true)
				pause (state.delay) // pace
				return evt3
			}
			if (topic[3]=='state'){
				def evt4 = createEvent(name: "InputBoolean", value: topic[2], data: [status: payload[0]], isStateChange: true)  //, key2: payload])
				pause (state.delay) // pace
				//log ("Device ${topic[2]} is a HA input boolean and is " +payload[0], "TRACE")
				return evt4
			}
			log ("Unhandled HA (b) MQTT parse  ${topic[0]}  ${topic[1]}  ${topic[2]}  ${topic[3]} - ${payload[0]}", "WARN")
			return
		}

		else if (topic[1]=='light') { 

			if (topic[3]=='friendly_name')
			{
				friendlyName=payload[0]
				if (friendlyName[0]=='"')  // remove double quotes
					{
						friendlyName=friendlyName.substring(1)
						friendlyName=friendlyName.substring(0, friendlyName.length() - 1)
				}
				log ("Device ${topic[2]} is a HA light and is called " +payload[0] + " " + friendlyName,"TRACE")
				def evt5= createEvent(name: "HALightDev", value: topic[2], data: [label: deQuote(friendlyName)], isStateChange: true)
				pause (state.delay) // pace
				return evt5
			}
			if (topic[3]=='state'){
				def evt6 = createEvent(name: "OnOff", value: topic[2], data: [status: payload[0]], isStateChange: true)  //, key2: payload])
				pause (state.delay) // pace
				return evt6
			}
			if (topic[3]=='brightness'){
				float dLevel = Float.parseFloat(payload[0])/2.55
				int iLevel = (int) dLevel.round()
				sLevel=iLevel.toString()
				def evt9 = createEvent(name: "Dim", value: topic[2], data: [level: sLevel], isStateChange: true)
				pause (state.delay) // pace
				return evt9
			}
			log ("Unhandled HA (c) MQTT parse  ${topic[0]}  ${topic[1]}  ${topic[2]}  ${topic[3]} - ${payload[0]}", "WARN")
			return
		}  // not a HA light
			log ("Unhandled (d) HA MQTT parse  ${topic[0]}  ${topic[1]}  ${topic[2]}  ${topic[3]} - ${payload[0]}", "WARN")
			
			
			
			
			

		} // not HA
	
	else if (topic[0]=="homie" && topic[1]== "${state.normHubName}"){ //local - look for incoming 'set' commands that control Hubitat devices here	
		if (topic[4]=="set") {
				 def evt12 = createEvent(name: "Command", value: topic[2], data: [state: payload[0], payload: payload, cmd: topic[3]], isStateChange: true)
				 pause (state.delay) // pace
			log ("Received this " + payload + "  " + payload.size(), "TRACE")
				 return evt12					
				}
				else {
					log ("Received unexpected message from homie " + topic + " " + payload, "WARN")
				}
			}// not homie local control
	
	else if (topic[0]=="homie" && topic[1]== state.homieDeviceDiscovery)  {   // remote subscribed homie 
			if (topic[2]=='$nodes') {  // can I pass this directly to the input selector ??
				log ("============= ${payload.size()} homie entries for device ${topic[1]} =============",, "INFO")
				return
			}
		
			if (topic[3]=='onoff') {
				def evt1 = createEvent(name: "OnOff", value: topic[2], data: [status: payload[0], topic: alphaV1parseMqttMessage(description).topic], isStateChange: true)  //, key2: payload])
				pause (state.delay) // pace
				return evt1
			}

			else if (topic[3]=='dim' && topicCount==4) {  // TODO is this level handling problematic assuming 1.0 ?
				float convertedNumber = Float.parseFloat(payload[0])*100
				int intLevel = convertedNumber = convertedNumber.round()
				adjLevel=intLevel.toString()
				def evt2 = createEvent(name: "Dim", value: topic[2], data: [state: "level", level: adjLevel, topic: alphaV1parseMqttMessage(description).topic], isStateChange: true)
				pause (state.delay) // pace
				return evt2
			}
		
			else if (topic[3]=='$type') {
				//log ("Got a type of " + payload[0] + " for " + topic, "TRACE")
				switch (payload[0]) {
					case 'switch':
						def evt33 = createEvent(name: "OnOffDev", value: topic[2], isStateChange: true)
						break
					case 'light':
						evt33 = createEvent(name: "DimDev", value: topic[2], isStateChange: true)
						break
					case 'sensor':
						evt33 = createEvent(name: "SensorDev", value: topic[2], isStateChange: true)
						break
					case 'thermostat':
						log ("homie " + payload[0] +" type not handled yet for device: "+ topic,"WARN")
						break
					case 'socket':
						def evt33 = createEvent(name: "OnOffDev", value: "hiccppup", isStateChange: true)
						break
					default:			
						log ("homie " + payload[0] +" type not handled for device: "+ topic,"WARN")	
					    break
				}
					pause (state.delay)
					return evt33  // TODO - need to sure it exists .. OK to return from here inside an else ?  isStateChange: true needed otherwise if no change to value: event is sent
			}
			else if (topic[3]=='$name') {  
				 log("Received homie name from MQTT ${topic[2]} " + status, "TRACE")
				 def evt0 = createEvent(name: "LabelDevice", value: "MQTT:homie_"+topic[2], data: [label: payload[0]], isStateChange: true)
				 pause (state.delay) // pace
				 return evt0
			 }
	} // end remote homie

	else {  // unhandled parse messages arrive here
		log ("ad hoc MQTT parse  alphaV1parseMqttMessage(description).topic       ${payload[0]}", "DEBUG")
		sendEvent (name: "Lookup", value: payload[0], data: [topic: alphaV1parseMqttMessage(description).topic], isStateChange: true) 

	}
}

def deQuote (s) {
 	s=s.replaceAll('^\"|\"$', "")
	return s
}

def reset()
	{
		alphaV1mqttDisconnect(device)
		log ("Resetting MQTT connection", "INFO")
		initialize()
	}
	
def setStateVar(var,value)
	{
	if (var == "logLevel"){
		state.logLevel = value.toInteger()
		log ("Log Level set to " + value,"INFO")
	}
	else if (var == "homieDevice"){
		state.homieDeviceDiscovery = value
		log ("homie discovery is for device: " + value, "INFO")
	}
	else if (var == "HAStatestreamTopic"){
		state.HAStatestreamTopic = value
		log ("HAStatestreamTopic is " + value,"INFO")
	}
	else if (var == "normHubName") {
		state.normHubName = value
		log ("Normalised hub name is " + value,"INFO")	
	}
}

/*   // This was for when using device children
def createChild (String Name)  // For child devices of this device
	{
	log ("Is this createChild ever called ??", "ERROR ")
	//deleteChildDevice("MQTT-"+ Name)	
	try { 
   		addChildDevice("ukusa", "MQTT Switch", "MQTT-"+Name, [name: Name, isComponent: false])	
	} catch(Exception ex) {
      	//log ("addChild failed for " +Name + " " +(ex.toString()), "DEBUG")
}	
	//addChildDevice("ukusa", "MQTT Switch", "MQTT-"+Name, [name: Name, isComponent: false])	
	}

def deleteChild (String Name) // For child devices of this device
	{
	log ("Deleting child MQTT-${Name}", "DEBUG")
	deleteChildDevice("MQTT-"+ Name)
	}

def setStateTopic (String Name, String Topic)
{
	log ("Setting state topic for " + Name + " " + Topic, "TRACE")
	def child= getChildDevice("MQTT-"+Name)
	//log ("Child device id: $child.id", "TRACE")
	// TODO only do this if valid id
	child.setStateTopic(Topic)
}
def setCommandTopic (String Name, String Topic)
{
	//return
	log ("Setting state topic for " + Name + " " + Topic, "TRACE")
	def child= getChildDevice("MQTT-"+Name)
	//log ("Child device id: $child.id", "TRACE")
	// TODO only do this if valid id
	child.setCommandTopic(Topic)
}
*/

def pause(millis) {
	pauseExecution(millis)	
}

def log(data, type) {

	data = "MQTT> ${data ?: ''}"
    if (determineLogLevel(type) >= state.logLevel) {
        switch (type?.toUpperCase()) {
            case "TRACE":
                log.trace "${data}"
                break
            case "DEBUG":
                log.debug "${data}"
                break
            case "INFO":
                log.info "${data}"
                break
            case "WARN":
                log.warn "${data}"
                break
            case "ERROR":
                log.error "${data}"
                break
			case "DISABLED":
			    break
            default:
                log.error "MQTT -- ${device.label} -- Invalid Log Setting"
        }
    }
}

private determineLogLevel(data) {
    switch (data?.toUpperCase()) {
        case "TRACE":
            return 0
            break
        case "DEBUG":
            return 1
            break
        case "INFO":
            return 2
            break
        case "WARN":
            return 3
            break
        case "ERROR":
        	return 4
            break
		case "DISABLED":
		    return 5
		    break
        default:
            return 1
    }
}
